The Gaming Room is a client focused on creating multi-platform, multiplayer gaming experiences. For this project, they envisioned a game called Draw It or Lose It, which is loosely inspired by classic drawing-based guessing games. They wanted software capable of handling multiple game instances simultaneously, with support for teams, real-time image rendering from a stock image library, and high responsiveness across operating platforms. Additionally, the system had to scale efficiently for potentially thousands of users while ensuring secure, fast communication between clients.

In developing the documentation, one thing I did particularly well was structuring the design into clear, functional sections—defining memory and storage needs, outlining distributed system communication, and emphasizing platform scalability and security. This made it easier to align each technical choice with client expectations and performance requirements.

Working through the design document helped lay a solid foundation for code development. It forced me to think about the full system lifecycle—how users interact with the platform, where images are stored and retrieved, how memory is allocated during gameplay, and how different components communicate in real time. It was especially useful in shaping a modular, scalable architecture from the outset.

If I were to revise one part of the documentation, I’d revisit the section on distributed systems and dive deeper into redundancy and latency considerations. Adding diagrams of the communication flow or fault-recovery plans would make the design more robust and easier to implement down the line.

To interpret the user’s needs, I paid attention to functional expectations—such as real-time image display and multi-user interaction—as well as non-functional ones like scalability and performance. These were implemented through features like content delivery networks, caching strategies, and cloud-based storage. It’s essential to consider user needs in software design because it’s the cornerstone of usability, satisfaction, and long-term success. Software that doesn’t respond to real-world usage patterns simply won’t be adopted.

When approaching the software design, I used a blend of top-down and object-oriented strategies. I broke down the system into high-level components—like storage, rendering, and networking—then built out detailed behaviors and interactions. In the future, I’d continue using this layered approach, integrating feedback loops earlier and working closely with mockups and flow diagrams to validate the design against user expectations before development begins.
